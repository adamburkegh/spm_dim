package org.processmining.plugins.etm.experiments;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.info.impl.XLogInfoImpl;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XesXmlGZIPSerializer;
import org.processmining.plugins.etm.model.narytree.test.LogCreator;
import org.processmining.plugins.etm.utils.LogUtils;

/**
 * This class contains several static methods to instantly create minimalistic
 * (i.e. only activity and lifecycle attributes) standard event logs
 * 
 * @author jbuijs
 * 
 */
public class StandardLogs {

	public static void main(String[] args) {
		/*-
		toFile(createDefaultLog(), "000RunEx-Default");
		toFile(createConfig2(), "000RunEx-Config2");
		toFile(createConfig3(), "000RunEx-Config3");
		toFile(createConfig4(), "000RunEx-Config4");
		/**/

		toFile(createMergedLog(),
				"C://Users//jbuijs//Documents//PhD//Projects//Small things//Simple test logs//000RunEx-Merged");

		//toCoSeNets();
	}

	/**
	 * Creates merged event log from DefaultLog, and Config2-4
	 * 
	 * @return
	 */
	public static XLog createMergedLog() {
		return LogUtils.mergeLogs(createDefaultLog(), createConfig2(), createConfig3(), createConfig4());
	}

	/**
	 * Stores the provided XLog instance in the provided filename (no filename
	 * extension should be provided)
	 * 
	 * @param log
	 * @param name
	 */
	public static void toFile(XLog log, String name) {
		log.getClassifiers().add(XLogInfoImpl.STANDARD_CLASSIFIER);

		try {
			XesXmlGZIPSerializer ser = new XesXmlGZIPSerializer();
			OutputStream out = new FileOutputStream(name + "." + ser.getSuffices()[0]);
			XConceptExtension.instance().assignName(log, name);
			ser.serialize(log, out);
			out.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
	 * Creates a simplistic event log containing the traces ABCDEG and B1B2D1D2
	 */
	public static XLog createTestLog() {
		//A-AND(B,C,XOR(D,tau))-XOR(E,F)-G
		return LogCreator.createLog(new String[][] { { "A", "B", "C", "D", "E", "G" }, { "B1", "B2", "D1", "D2" } },
				new int[] { 1, 1 });
	}

	/**
	 * Creates the default event log (100 traces) used as running example
	 * (generated by the process tree SEQ(A , AND(B,C,XOR(D,tau)),XOR(E,F),G)
	 * 
	 * @return
	 */
	public static XLog createDefaultLog() {
		//A-AND(B,C,XOR(D,tau))-XOR(E,F)-G
		return LogCreator.createLog(new String[][] { { "A", "B", "C", "D", "E", "G" },
				{ "A", "B", "C", "D", "F", "G" }, { "A", "B", "D", "C", "E", "G" }, { "A", "B", "D", "C", "F", "G" },
				{ "A", "B", "C", "F", "G" }, { "A", "C", "B", "E", "G" }, { "A", "D", "B", "C", "F", "G" },
				{ "A", "D", "B", "C", "E", "G" }, { "A", "D", "C", "B", "F", "G" }, { "A", "C", "D", "B", "F", "G" },
				{ "A", "C", "B", "F", "G" } }, new int[] { 6, 38, 12, 26, 8, 1, 1, 1, 4, 2, 1 });
	}

	/**
	 * Creates the default log * 10 and adds 20 'noisy' traces that do not fit
	 * the process tree
	 * 
	 * @return
	 */
	public static XLog createDefaultLogWithNoise() {
		//A-AND(B,C,XOR(D,tau))-XOR(E,F)-G
		return LogCreator.createLog(new String[][] { { "A", "B", "C", "D", "E", "G" },
				{ "A", "B", "C", "D", "F", "G" }, { "A", "B", "D", "C", "E", "G" }, { "A", "B", "D", "C", "F", "G" },
				{ "A", "B", "C", "F", "G" }, { "A", "C", "B", "E", "G" }, { "A", "D", "B", "C", "F", "G" },
				{ "A", "D", "B", "C", "E", "G" }, { "A", "D", "C", "B", "F", "G" },
				{ "A", "C", "D", "B", "F", "G" },
				{ "A", "C", "B", "F", "G" }
				//NOISE
				, { "A", "B", "C", "G" }, { "A", "C", "B", "D", "G" }, { "A", "D", "E", "G" }, { "A", "C", "F", "G" },
				{ "A", "B", "C", "D", "E", "F", "G" }, { "A", "B", "D", "E", "G" }, { "A", "C", "D", "F", "G" } },
				new int[] { 60, 380, 120, 260, 80, 10, 10, 10, 40, 20, 10
						//NOISE	
						, 3, 4, 4, 3, 2, 2, 2 });
	}

	/**
	 * Creates the event log of configuration 2 as used in the paper
	 * "Mining Configurable Process Models from Collections of Event Logs"
	 * containing the traces A B1 B2 C D2 E G and A B1 B2 C D2 F G
	 * 
	 * @return
	 */
	public static XLog createConfig2() {
		//WRT to default log: B1->B2->C->D2 only sequence (e.g. no parallelism) and 70 traces instead of 100
		return LogCreator.createLog(new String[][] { { "A", "B1", "B2", "C", "D2", "E", "G" },
				{ "A", "B1", "B2", "C", "D2", "F", "G" } }, new int[] { 20, 50 });
	}

	/**
	 * Creates the event log of configuration 3 as used in the paper
	 * "Mining Configurable Process Models from Collections of Event Logs"
	 * containing the traces A C B E and A C B F
	 * 
	 * @return
	 */
	public static XLog createConfig3() {
		//WRT to default log: C->B only sequence (e.g. no parallelism, no D or D2), never G and 200 traces instead of 100
		return LogCreator.createLog(new String[][] { { "A", "C", "B", "E", }, { "A", "C", "B", "F" } }, new int[] {
				120, 80 });
	}

	/**
	 * Creates the event log of configuration 4 as used in the paper
	 * "Mining Configurable Process Models from Collections of Event Logs"
	 * containing the traces A B1 D B2 C E and A B1 D2 B2 C F
	 * 
	 * @return
	 */
	public static XLog createConfig4() {
		//WRT to default log: B1->DxD2->B2->C only sequence, D=>E and D2=>F (e.g. dependency), never G, 105 traces
		return LogCreator.createLog(new String[][] { { "A", "B1", "D", "B2", "C", "E" },
				{ "A", "B1", "D2", "B2", "C", "F" } }, new int[] { 45, 60 });
	}

}
