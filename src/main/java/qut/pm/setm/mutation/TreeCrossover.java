package qut.pm.setm.mutation;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.processmining.plugins.etm.CentralRegistry;
import org.uncommons.maths.random.Probability;
import org.uncommons.watchmaker.framework.operators.AbstractCrossover;

import qut.pm.spm.ppt.ProbProcessTree;
import qut.pm.spm.ppt.ProbProcessTreeCheck;
import qut.pm.spm.ppt.ProbProcessTreeFactory;
import qut.pm.spm.ppt.ProbProcessTreeNode;
import qut.pm.spm.ppt.ProbProcessTreeProjector;
import qut.pm.spm.ppt.ProcessTreeConsistencyException;

/**
 * Cross-over operator for the trees of {@link Node}s. Adapted from watchmaker and jbuijs ETM.
 * 
 */
public class TreeCrossover<R extends ProbProcessTree> extends AbstractCrossover<ProbProcessTree> {

	private static final Logger LOGGER = LogManager.getLogger();
	
	protected CentralRegistry registry;

	public TreeCrossover(int crossoverPoints, Probability crossoverProbability, CentralRegistry registry) {
		super(crossoverPoints, crossoverProbability);
		this.registry = registry;
	}

	/**
	 * Swaps randomly selected sub-trees between the two parents.
	 * 
	 * @param parent1
	 *            The first parent.
	 * @param parent2
	 *            The second parent.
	 * @param numberOfCrossoverPoints
	 *            The number of cross-overs to perform.
	 * @param rng
	 *            A source of randomness.
	 * @return A list of two offspring, generated by swapping sub-trees between
	 *         the two parents.
	 */
	@Override
	protected List<ProbProcessTree> mate(ProbProcessTree parent1, ProbProcessTree parent2, int numberOfCrossoverPoints, Random rng) {
		if (parent1.isLeaf() || parent2.isLeaf())
			return new ArrayList<>();
		LOGGER.debug("Mating " + parent1 + " to " + parent2);
		LOGGER.debug("Trying for " + numberOfCrossoverPoints + " crossovers");
		List<ProbProcessTree> offspring = new ArrayList<ProbProcessTree>(2);
		try {
			ProbProcessTreeNode tree1 = (ProbProcessTreeNode)ProbProcessTreeFactory.copy(parent1);
			ProbProcessTreeNode tree2 = (ProbProcessTreeNode)ProbProcessTreeFactory.copy(parent2); 
	
			ProbProcessTreeCheck.exceptIfInconsistent(tree1);
			ProbProcessTreeCheck.exceptIfInconsistent(tree2);
	
			//Prepare the offspring list
	
			//Now apply crossover as many times as required
			for (int i = 0; i < numberOfCrossoverPoints; i++) {
				//Find random crossover points
				int pointTree1 = rng.nextInt(tree1.size()-1);
				int pointTree2 = rng.nextInt(tree2.size()-1);
	
				//Now apply the swap but create 2 new trees otherwise the 2nd swap swaps a different node than intended
				ProbProcessTree sub1 =  ProbProcessTreeProjector.findSubNode(tree1, pointTree1);
				ProbProcessTree sub2 =  ProbProcessTreeProjector.findSubNode(tree2, pointTree2);
				ProbProcessTreeNode t1new = ProbProcessTreeProjector.replaceSubNode(tree1, pointTree1, sub2 );
				ProbProcessTreeNode t2new = ProbProcessTreeProjector.replaceSubNode(tree2, pointTree2, sub1 );
	
				ProbProcessTreeCheck.exceptIfInconsistent(t1new);
				ProbProcessTreeCheck.exceptIfInconsistent(t2new);
	
				//Update the pointers
				tree1 = t1new;
				tree2 = t2new;
			}
			offspring.add(tree1);
			offspring.add(tree2);
		}catch (ProcessTreeConsistencyException ptce) {
			LOGGER.error("Inconsistency mating " + parent1 + " to " + parent2);
		}
		return offspring;
	}
}
